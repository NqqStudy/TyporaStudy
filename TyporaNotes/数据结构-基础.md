# 1 数组

# C++面试宝典

## 1.1 数组Array和链表List的区别

- **数组特点**

**数组将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素**。**数组的插入数据和删除数据效率低**，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。**数组的随机读取效率很高**。因为数组是连续的，**知道每一个数据的内存地址，可以直接找到给地址的数据**。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。并且数组不利于扩展，数组定义的空间不够时要重新定义数组

- **数组优点**

1. 随机访问性强
2. 查找速度快

- **数组缺点**

1. 插入和删除效率低
2. 可能浪费内存
3. 内存空间要求高，必须有足够的连续内存空间
4. 数组大小固定，不能动态拓展

- **链表特点**

链表中的元素在内存中不是顺序存储的，而是**通过存在元素中的指针联系到一起**。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置，但是**增加和删除一个元素对于链表数据结构就非常简单，只要修改元素中的指针就可以**。如果应用需要经常插入和删除元素你就需要用链表数据结构。不指定大小，扩展方便。**链表大小不用定义，数据随意增删**

- **链表优点**

1. 插入删除速度快
2. 内存利用率高，不会浪费内存
3. 大小没有固定，拓展很灵活

- **链表缺点**

1. 不能随机查找，必须从第一个开始遍历，查找效率低

## 1.2 判断数组是否有重复的数

- 长度为N的整形数组，数组每个元素的取值范围是[0,n-1]，判断该数组否有重复的数，请说一下思路并手写代码
- 把每个数放到自己对应序号的位置上，如果其他位置上有和自己对应序号相同的数，那么即为有重复的数值。时间复杂度为O(N)，同时为节省空间复杂度，可以在原数组上进行操作，空间复杂度为O(1)

```cs
bool IsDuplicateNumber(int *array, int n)
{
if(array==NULL) return false;
int i,temp;
for(i=0;i<n;i++)
{
while(array[i]!=i)// 把每个数放在自己对应序号的位置
{
if(array[array[i]]==array[i])// 如果该位置有相同的数，返回true
   return true;
   temp = array[array[i]];
   array[array[i]] = array[i];// 如果没有相同的数，将两个数置换位置，使每个数放到自己对应序号的位置上
   array[i] = temp;
}
}
return false;
}
```

# 随想录数组理论基础

- 数组是非常基础的数据结构，面试中，考察数组的题目一般在思维上都不难，**主要是考察对代码的掌控能力**。就是说，想法很简单，但实现起来可能就不是那么回事
- 要知道数组在内存中的存储方式，这样才能真正理解数组相关的面试题
- **数组是存放在连续内存空间上的相同类型数据的集合**，数组可以方便的通过下标索引的方式获取到下标对应的数据

举一个字符数组的例子，如图所示：

![算法通关数组](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)

需要两点注意的是

- **数组下标都是从0开始**
- **数组内存空间的地址是连续的**

**因为数组的在内存空间的地址是连续的，所以在删除或者增添元素的时候，难免要移动其他元素的地址**

例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)

- 大家如果使用C++的话，要注意vector 和 array的区别，vector的底层实现是array，严格来讲vector是容器，不是数组。**数组的元素是不能删的，只能覆盖**

那么二维数组直接上图，大家应该就知道怎么回事

![算法通关数组2](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%842.png)

**二维数组在内存的空间地址是连续的么？**

不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的，C++测试代码如下：

```cpp
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0][2] << endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1][2] << endl;
}

int main() {
    test_arr();
}
```

测试地址为

```text
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
```

- 注意地址为16进制，可以看出**二维数组地址是连续一条线**
- 可能看不懂内存地址，我就简单介绍一下， 0x7ffee4065820 与 0x7ffee4065824 差了一个4，就是4个字节，因为这是一个int型的数组，所以两个相邻数组元素地址差4个字节
- 0x7ffee4065828 与 0x7ffee406582c 也是差了4个字节，在16进制里8 + 4 = c，c就是12

如图：

![数组内存](https://code-thinking-1253855093.file.myqcloud.com/pics/20210310150641186.png)

- **可以看出在C++中二维数组在地址空间上是连续的**
- 像Java是没有指针的，同时也不对程序员暴露其元素的地址，寻址操作完全交给虚拟机
- 所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验

```java
public static void test_arr() {
    int[][] arr = {{1, 2, 3}, {3, 4, 5}, {6, 7, 8}, {9,9,9}};
    System.out.println(arr[0]);
    System.out.println(arr[1]);
    System.out.println(arr[2]);
    System.out.println(arr[3]);
}
```

输出的地址为：

```text
[I@7852e922
[I@4e25154f
[I@70dea4e
[I@5c647e05
```

- 这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值，可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续，所以Java的二维数组可能是如下排列的方式：


![算法通关数组3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201214111631844.png)

# 2 链表

# C++面试宝典

## 2.1 合并两个有序链表

```cpp
// 手写代码
class Solution {
public:
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
if(l1 == NULL)
{
return l2;
}
if(l2 == NULL)
{
return l1;
}
if(l1->val < l2->val)
{
    l1->next = mergeTwoLists(l1->next,l2);
    return l1;
}
else
{
    l2->next = mergeTwoLists(l1,l2->next);
    return l2;
}
}
};
```

## 2.2 反转链表

```css
// 手写代码
Void reversal_list(mylist * a_list)
{
mylist * forward_node = nullptr;
mylist * cur_node = a_list->next;
mylist* next_node = cur_node->next;
if(cur_node == nullptr)
{
return ;
}
while(1)
{
cur_node->next = forward_node;
forward_node = cur_node;
cur_node = next_node;
if(cur_node == nullptr)
{
break;
}
next_node = cur_node->next;
}
a_list->next = forward_node;
}
```

## 2.3 判断是否为回文链表

思路：使用栈存储链表前半部分，然后一个个出栈，与后半部分元素比较，如果链表长度未知，可以使用**快慢指针**的方法，**将慢指针指向的元素入栈，然后如果快指针指向链表尾部，此时慢指针指向链表中间**

```css
bool is_palindromic_list2(mylist *a_list)
{
if(a_list == nullptr)
{
return false;
}
stack<int>list_value;
mylist * fast =a_list;
mylist *slow =a_list;
while(fast->next!=nullptr && fast->next->next!=nullptr)
{
list_value.push(slow->next->value);
slow = slow->next;
fast = fast->next->next;
}
cout<<"middle elem value is "<<slow->next->value<<endl;
if(fast->next != nullptr)
{
cout<<"the list has odd num of node"<<endl;
slow = slow->next;
}
int cur_value;
while(!list_value.empty())
{
cur_value = list_value.top();
cout<<"stack top value is"<<cur_value<<endl;
cout<<"list value is "<<slow->next->value<<endl;
if(cur_value != slow->next->value)
{
return false;
}
list_value.pop();
slow = slow->next;
}
return true;
}
```

## 2.4 手写链表反转

```cpp
struct ListNode {
int val;
struct ListNode *next;
ListNode(int x) :val(x), next(NULL) {}
}
ListNode* ReverseList(ListNode* pHead)
{
if(!pHead||!pHead->next)return pHead;
ListNode *pre=nullptr;
ListNode *p=pHead;
ListNode *next=pHead->next;
while(p)
{
p->next=pre;
pre=p;
p=next;
if(next)
next=next->next;
}
return pre;
}
```

## 2.5 判断两个单向链表是否相交

- **单向链表**

单向链表（单链表）是链表的一种，其特点是链表的链接方向是单向的，**对链表的访问要通过顺序读取从头部开始**。链表是使用指针进行构造的列表，又称为**结点列表**，因为链表是由一个个结点组装起来的，其中**每个结点都有指针成员变量指向列表中的下一个结点**

**列表是由结点构成，head指针指向第一个成为表头结点，而终止于最后一个指向nuLL的指针**

![img](https://uploadfiles.nowcoder.com/images/20190315/308571_1552656719974_C970C36362F2BC68DE7B929A836787CD)

- **判断两个链表是否相交**

1. 方法1

链表相交之后，后面的部分节点全部共用，可以用2个指针分别从这两个链表头部走到尾部，最后判断尾部指针的地址信息是否一样，若一样则代表链表相交！

2. 方法2

可以把其中一个链表的所有节点地址信息存到数组中，然后把另一个链表的每一个节点地址信息遍历数组，若相等，则跳出循环，说明链表相交。进一步优化则是进行hash排序，建立hash表

# 随想录链表理论基础

- 链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是**数据域**，一个是**指针域**(**存放指向下一个节点的指针**)，**最后一个节点的指针域指向null(空指针的意思)**

- 链表的**入口节点称为链表的头结点也就是head**


如图所示： ![链表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png)

## 2.6 链表的类型

接下来说一下链表的几种类型

### 2.6.1 单链表

刚刚说的就是单链表

### 2.6.2 双链表

- **单链表中的指针域只能指向节点的下一个节点**
- 双链表：**每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点**

- 双链表既可以向前查询也可以向后查询


如图所示： ![链表2](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)

### 2.6.3 循环链表

- 循环链表，顾名思义，就是链表首尾相连

- 循环链表可以用来解决约瑟夫环问题


![链表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)

## 2.7 链表存储方式

- 数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的

- 链表是通过指针域的指针链接在内存中各个节点

- 所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理


如图所示：

![链表3](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

- 这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起


## 2.8 链表的定义

链表节点的定义，很多同学在面试时都写不好。这是因为平时在刷leetcode的时候，链表的节点都默认定义好了，直接用就行了，所以同学们都没有注意到链表的节点是如何定义的。而在面试的时候，一旦要自己手写链表，就写的错漏百出。

这里给出C/C++的定义链表节点方式，如下所示：

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

有同学说不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。

但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：

**通过自己定义构造函数初始化节点**：

```cpp
ListNode* head = new ListNode(5);
```

**使用默认构造函数初始化节点**：

```cpp
ListNode* head = new ListNode();
head->val = 5;
```

- 所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！


## 2.9 链表的操作

### 2.9.1 删除节点

删除D节点，如图所示：

![链表-删除节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)

- 只要将C节点的next指针 指向E节点就可以。

- 那有同学说D节点不是依然存留在内存里么？只不过是没有在这个链表里而已

- 是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存

- 其他语言例如Java、Python，就有自己的内存回收机制，就不用自己手动释放


### 2.9.2 添加节点

如图所示：

![链表-添加节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

## 2.10 性能分析

再把链表的特性和数组的特性进行一个对比，如图所示：

![链表-链表与数据性能对比](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

- 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组

- 链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景


# 3 字符串

# C++面试宝典

## 3.1 找到第一个不重复字符

[解决代码](https://blog.csdn.net/qq_28662831/article/details/97651525)

- 给一个字符串，找出第一个不重复的字符，如“abbbabcd”，则第一个不重复就是c
- 使用**哈希**的思想，建立256个bool数组array，初始都为false,从头开始扫描字符串，扫到一个，将以其ascii码为下标的元素置true。例如扫描到A的时候，执行：array['A']=true。第二边扫描，扫到一个字母就以其ascii码为下标，去array数组中看其值，如果是true,返回改字母，如果是false，继续扫描下一个字母

# 4 树

# C++面试宝典

## 4.1 红黑树和AVL树的定义，特点以及二者区别

### 4.1.1 平衡二叉树(AVL树)

- 平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1。一句话表述为：**以树中所有结点为根的树的左右子树高度之差的绝对值不超过1**。将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的

### 4.1.2 红黑树

- 红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑(非红即黑)。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以**对于搜索，插入，删除操作较多的情况下，通常使用红黑树**

性质

1. 每个节点非红即黑
2. 根节点是黑的
3. 每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的
4. 如果一个节点是红色的，则它的子节点必须是黑色的
5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点

### 4.1.3 区别

- AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转

## 4.2 哈夫曼编码

哈夫曼编码是哈夫曼树的一种应用，广泛用于**数据文件压缩**。**哈夫曼编码算法用字符在文件中出现的频率来建立使用0，1表示个字符的最优表示方式**，其具体算法如下：

- 哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T
- 算法以|C|个叶结点开始，执行|C|－1次的“合并”运算后产生最终所要求的树T
- 假设编码字符集中每一字符c的频率是f(c)。以f为键值的优先队列Q用在贪心选择时有效地确定算法当前要合并的2棵具有最小频率的树。一旦2棵具有最小频率的树合并后，产生一棵新的树，其频率为合并的2棵树的频率之和，并将新树插入优先队列Q。经过n－1次的合并后，优先队列中只剩下一棵树，即所要求的树T

## 4.3 map底层为什么用红黑树实现

1、**红黑树**

- 红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑(非红即黑)。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树

- **性质**

1. 每个节点非红即黑
2. 根节点是黑的
3. 每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的
4. 如果一个节点是红色的，则它的子节点必须是黑色的
5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点

2、**平衡二叉树(AVL树)**

- 红黑树是在AVL树的基础上提出来的。平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1
- AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1
- 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的

3、**红黑树较AVL树的优点**

AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转。

所以红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树。

## 4.4 B+树

**B+是一种多路搜索树，主要为磁盘或其他直接存取辅助设备而设计的一种平衡查找树**。在B+树中，每个节点的可以有多个孩子，并且按照关键字大小有序排列。所有记录节点都是按照键值的大小顺序存放在同一层的叶节点中。相比B树，其具有以下几个特点：

- 每个节点上的指针上限为2d而不是2d+1(d为节点的出度)
- 内节点不存储data，只存储key
- 叶子节点不存储指针

## 4.5 map和unordered_map的底层实现

- **map底层是基于红黑树实现的，因此map内部元素排列是有序的**。而**unordered_map底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的**

## 4.6 map和unordered_map优点和缺点

**map是基于红黑树实现的**

- **优点**

1. 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作

2. map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn

- **缺点**

1. 查找、删除、增加等操作平均时间复杂度较慢，与n相关

**unordered_map底层是一个哈希表**

- **优点**

1. 查找、删除、添加的速度快，时间复杂度为常数级O(c)

- **缺点**

1. 因为unordered_map内部基于哈希表，以(key,value)对的形式存储，因此空间占用率高

2. unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)

## 4.7 epoll怎么实现的

Linux epoll机制是通过**红黑树和双向链表**实现的

- 首先**通过epoll_create()系统调用在内核中创建一个eventpoll类型的句柄，其中包括红黑树根节点和双向链表头节点**
- 然后**通过epoll_ctl()系统调用，向epoll对象的红黑树结构中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败**
- 最后**通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞**。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件

## 4.8 Top(K)问题

1. **直接全部排序**(只适用于内存够的情况)

当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个

这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用

2. **快速排序的变形**(只使用于内存够的情况)

一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  > K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index < K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销

3. **最小堆法**

这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数

4. **分治法**

将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N\*K个数据，如果内存不能容纳N\*K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理

5. **Hash法**

如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据

## 4.9 C++两种map

unordered_map（哈希表)和map（红黑树）

## 4.10 红黑树了解吗

参考博客https://blog.csdn.net/tanrui519521/article/details/80980135

## 4.11 红黑树的性质还有左右旋转

1. **平衡二叉树(AVL树)**

- 红黑树是在AVL树的基础上提出来的
- 平衡二叉树又称为AVL树，是一种特殊的二叉排序树。其左右子树都是平衡二叉树，且左右子树高度之差的绝对值不超过1
- AVL树中所有结点为根的树的左右子树高度之差的绝对值不超过1
- 将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上的所有结点的平衡因子只可能是-1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的

2. **红黑树**

- 红黑树是在AVL树的基础上发展而来的。红黑树是一种二叉查找树，但在每个节点增加一个存储位表示节点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个节点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树，相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树

**性质**

1. 每个节点非红即黑
2. 根节点是黑的
3. 每个叶节点(叶节点即树尾端NULL指针或NULL节点)都是黑的
4. 如果一个节点是红色的，则它的子节点必须是黑色的
5. 对于任意节点而言，其到叶子点树NULL指针的每条路径都包含相同数目的黑节点

- 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。恢复红黑属性需要少量(O(log n))的颜色变更(这在实践中是非常快速的)并且不超过三次树旋转(对于插入是两次)。这允许插入和删除保持为 O(log n) 次

![img](https://uploadfiles.nowcoder.com/images/20190315/308571_1552656203034_7D91838E6EBEB8036D6138A019A0AF1A)

3. **红黑树较AVL树的优点**

- AVL 树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降；红黑树不是高度平衡的，算是一种折中，插入最多两次旋转，删除最多三次旋转
- 所以**红黑树在查找，插入删除的性能都是O(logn)，且性能稳定，所以STL里面很多结构包括map底层实现都是使用的红黑树**

4. **红黑树旋转**

- 旋转：红黑树的旋转是一种能保持二叉搜索树性质的搜索树局部操作。有左旋和右旋两种旋转，通过改变树中某些结点的颜色以及指针结构来保持对红黑树进行插入和删除操作后的红黑性质

- 左旋：对某个结点x做左旋操作时，假设其右孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的左孩子，y的左孩子成为x的右孩子

![img](https://uploadfiles.nowcoder.com/images/20190315/308571_1552656212115_1587159E7ADB036880D502D2927B9597)

- 右旋：对某个结点x做右旋操作时，假设其左孩子为y而不是T.nil：以x到y的链为“支轴”进行。使y成为该子树新的根结点，x成为y的右孩子，y的右孩子成为x的左孩子

![img](https://uploadfiles.nowcoder.com/images/20190315/308571_1552656223637_991B891FAD560CB072639E0791F9CBB7)

## 4.12 实现二叉树的层序遍历并输出

```cpp
void layerTrace(BTreeNode *T)
{
if(T== nullptr)return;
BTreeNode *p=T;
queue<BTreeNode*>q;
q.push(p);
while(!q.empty())
{
p=q.front();
q.pop();
cout<<<<p->data;
if(p->left!= nullptr)q.push(p->left);
if(p->right!= nullptr)q.push(p->right);
}
}```
```

## 4.13 手写代码二叉树序列化反序列化

- 序列化：必须保存一个中序遍历结果，然后外加一个前序或者后序遍历结果
- 反序列化：根据两次遍历生成的结果恢复二叉树，代码如下(前序和中序)：

~~~css
```TreeNode* helper(vector<int>pre,int startPre,int endPre,vector<int>in,int startIn,int endIn)
{
if(startPre>endPre||startIn>endIn)
return nullptr;
TreeNode * root=new TreeNode(pre[startPre]);
for(int i=startIn;i<=endIn;++i)
{
if(in[i]==pre[startPre])
{
root->left=helper(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);
root->right=helper(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);
break;
}
}
return root;
}
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin)
{
TreeNode *root=helper(pre,0,pre.size()-1,vin,0,vin.size()-1);
return root;
}
~~~

# 5 堆和栈

# C++面试宝典

## 5.1 简述stack overflow并举例子导致栈溢出

- **栈溢出概念**：栈溢出指的是程序向栈中某个变量中写入的字节数超过这个变量本身所申请的字节数，因而导致栈中与其相邻的变量的值被改变

- **栈溢出原因**

1. **局部数组过大**：当函数内部的数组过大时，有可能导致堆栈溢出。局部变量是存储在栈中的，因此好理解。解决这类问题的办法有两个，一是**增大栈空间**，二是**改用动态分配**，**使用堆(heap)而不是栈(stack)**
2. **递归调用层次太多**：递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出
3. **指针或数组越界**：这种情况最常见，例如进行字符串拷贝或处理用户输入等

栈溢出例子

```
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[]) {
char buf[256];
strcpy(buf,argv[1]);
printf("Input:%s\n",buf);
return 0;
}
```

上述代码中的strcpy(buf,argv[1]);这一行发生了缓冲区溢出错误，因为源缓冲区内容是用户输入的

## 5.2 栈和堆区别以及为什么栈要快(重点)

![内存模型](E:\BaiduSyncdisk\C++学习\B站C++学习\1.C++学习\0.C++系统学习\C++面试宝典笔记图片\内存模型.png)

- 堆和栈的区别：**堆由低地址向高地址扩展，栈由高地址向低地址扩展**
- **堆中的内存需要手动申请和手动释放**，**栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存**
- **堆中频繁调用malloc和free，会产生内存碎片，降低程序效率**。而栈由于其先进后出的特性，不会产生内存碎片
- 堆的分配效率较低，而栈的分配效率较高
- **栈的效率高**的原因：**栈是操作系统提供的数据结构**，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行。而**堆是由C/C++函数库提供**，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低

## 5.3 手写代码两个栈实现一个队列

```cpp
class Solution
{
public:
void push(int node) {
stack1.push(node);
}
int pop() {
if(stack2.size()!=0){
int tmp = stack2.top();
stack2.pop();
return tmp;
}
else{
while(stack1.size()!=0){
int tmp = stack1.top();
stack1.pop();
stack2.push(tmp);
}
return pop();
}
}
private:
stack<int> stack1;
stack<int> stack2;
}；
```

## 5.4 堆和栈的区别

1. **申请方式**

- 栈由系统自动分配和管理，堆由程序员手动分配和管理

2. **效率**

- 栈由系统分配，速度快，不会有内存碎片
- 堆由程序员分配，速度较慢，可能由于操作不当产生内存碎片

3. **扩展方向**

- 栈从高地址向低地址进行扩展，堆由低地址向高地址进行扩展

4. 程序局部变量是使用的栈空间，new/malloc动态申请的内存是堆空间，函数调用时会进行形参和返回值的压栈出栈，也是用的栈空间

## 5.5 小根堆特点

堆是一棵完全二叉树（如果一共有h层，那么1~h-1层均满，在h层可能会连续缺失若干个右叶子）。

- **小根堆**

若根节点存在左子女则根节点的值小于左子女的值；若根节点存在右子女则根节点的值小于右子女的值

- **大根堆**

若根节点存在左子女则根节点的值大于左子女的值；若根节点存在右子女则根节点的值大于右子女的值

# 6 排序

# C++面试宝典

## 6.1 手写快排的代码

```cpp
int once_quick_sort(vector<int> &data, int left, int right)
{
int key = data[left];
while (left < right)
{
while (left < right && key <= data[right])
{
right--;
}
if (left < right)
{
data[left++] = data[right];
}
while (left < right && key > data[left])
{
left++;
}
if (left < right)
{
data[right--] = data[left];
}
}
data[left] = key;
return left;
}
int quick_sort(vector<int> & data, int left, int right)
{
if (left >= right )
{
return 1;
}
int middle = 0;
middle = once_quick_sort(data, left, right);
quick_sort(data, left, middle-1);
quick_sort(data, middle + 1, right);
}；
```

## 6.2 求第k大的数

问题：请问求第k大的数的方法以及各自的复杂度是怎样的，当有相同元素时，还可以使用什么不同的方法求第k大的元素？

- 首先使用快速排序算法将数组按照从大到小排序，然后取第k个，其时间复杂度最快为O(nlogn)
- 使用堆排序，建立最大堆，然后调整堆，知道获得第k个元素，其时间复杂度为O(n+klogn)
- 首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数
- 利用快排思想，从数组中随机选择一个数i，然后将数组分成两部分Dl，Dr。Dl的元素都小于i，Dr的元素都大于i。然后统计Dr元素个数，如果Dr元素个数等于k-1,那么第k大的数即为k，如果Dr元素个数小于k,那么继续求Dl中第k-Dr大的元素；如果Dr元素个数大于k,那么继续求Dr中第k大的元素
- 当有相同元素的时候，首先利用哈希表统计数组中个元素出现的次数，然后利用计数排序的思想，线性从大到小扫描过程中，前面有k-1个数则为第k大的数，平均情况下时间复杂度为O(n)

## 6.3 各种排序算法及时间复杂度

- **插入排序**：对于一个带排序数组来说，其初始有序数组元素个数为1，然后从第二个元素，插入到有序数组中。对于每一次插入操作，从后往前遍历当前有序数组，如果当前元素大于要插入的元素，则后移一位；如果当前元素小于或等于要插入的元素，则将要插入的元素插入到当前元素的下一位中
- **希尔排序**：先将整个待排序记录分割成若干子序列，然后分别进行直接插入排序，待整个序列中的记录基本有序时，在对全体记录进行一次直接插入排序。其子序列的构成不是简单的逐段分割，而是将每隔某个增量的记录组成一个子序列。希尔排序时间复杂度与增量序列的选取有关，其最后一个值必须为1.
- **归并排序**：该算法采用**分治法**。对于包含m个元素的待排序序列，将其看成m个长度为1的子序列。然后两两合归并，得到n/2个长度为2或者1的有序子序列；然后再两两归并，直到得到1个长度为m的有序序列
- **冒泡排序**：对于包含n个元素的带排序数组，重复遍历数组，首先比较第一个和第二个元素，若为逆序，则交换元素位置；然后比较第二个和第三个元素，重复上述过程。每次遍历会把当前前n-i个元素中的最大的元素移到n-i位置。遍历n次，完成排序
- **快速排序**：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。
- 选择排序：每次循环，选择当前无序数组中最小的那个元素，然后将其与无序数组的第一个元素交换位置，从而使有序数组元素加1，无序数组元素减1.初始时无序数组为空
- 堆排序：堆排序是一种选择排序，利用堆这种数据结构来完成选择。其算法思想是将带排序数据构造一个最大堆（升序）/最小堆（降序），然后将堆顶元素与待排序数组的最后一个元素交换位置，此时末尾元素就是最大/最小的值。然后将剩余n-1个元素重新构造成最大堆/最小堆

各个排序的时间复杂度、空间复杂度及稳定性如下：

![img](https://uploadfiles.nowcoder.com/images/20190313/311436_1552474444160_93CF294B0FB45C83DC616C5700184F2E)

## 6.4 排序算法及其复杂度

1. **冒泡排序**

从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。

稳定性：稳定

平均时间复杂度：O(n ^ 2)

2. **插入排序**

从待排序的n个记录中的第二个记录开始，依次与前面的记录比较并寻找插入的位置，每次外循环结束后，将当前的数插入到合适的位置。

稳定性：稳定

平均时间复杂度：O(n ^ 2)

3. **希尔排序**(缩小增量排序)

希尔排序法是对相邻指定距离(称为增量)的元素进行比较，并不断把增量缩小至1，完成排序。

希尔排序开始时增量较大，分组较多，每组的记录数目较少，故在各组内采用直接插入排序较快，后来增量di逐渐缩小，分组数减少，各组的记录数增多，但由于已经按di−1分组排序，文件叫接近于有序状态，所以新的一趟排序过程较快。因此希尔 排序在效率上比直接插入排序有较大的改进。

在直接插入排序的基础上，将直接插入排序中的1全部改变成增量d即可，因为希尔排序最后一轮的增量d就为1。

稳定性：不稳定

平均时间复杂度：希尔排序算法的时间复杂度分析比较复杂，实际所需的时间取决于各次排序时增量的个数和增量的取值。时间复杂度在O(n ^ 1.3)到O(n ^ 2)之间。

4. **选择排序**

从所有记录中选出最小的一个数据元素与第一个位置的记录交换；然后在剩下的记录当中再找最小的与第二个位置的记录交换，循环到只剩下最后一个数据元素为止。

稳定性：不稳定

平均时间复杂度：O(n ^ 2)

5、**快速排序**

1）从待排序的n个记录中任意选取一个记录（通常选取第一个记录）为分区标准;

2）把所有小于该排序列的记录移动到左边，把所有大于该排序码的记录移动到右边，中间放所选记录，称之为第一趟排序；

3）然后对前后两个子序列分别重复上述过程，直到所有记录都排好序。

稳定性：不稳定

平均时间复杂度：O(nlogn)

6. **堆排序**

堆：

- 完全二叉树或者是近似完全二叉树
- 大顶堆：父节点不小于子节点键值，小顶堆：父节点不大于子节点键值。左右孩子没有大小的顺序

堆排序在选择排序的基础上提出的，步骤：

- 建立堆
- 删除堆顶元素，同时交换堆顶元素和最后一个元素，再重新调整堆结构，直至全部删除堆中元素

稳定性：不稳定

平均时间复杂度：O(nlogn)

7. **归并排序**

采用分治思想，现将序列分为一个个子序列，对子序列进行排序合并，直至整个序列有序

稳定性：稳定

平均时间复杂度：O(nlogn)

8. **计数排序**

思想：如果比元素x小的元素个数有n个，则元素x排序后位置为n+1。

步骤：

1）找出待排序的数组中最大的元素；

2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项；

3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；

4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。

稳定性：稳定

时间复杂度：O(n+k)，k是待排序数的范围。

9. **桶排序**

步骤：

1）设置一个定量的数组当作空桶子； 常见的排序算法及其复杂度：

2）寻访序列，并且把记录一个一个放到对应的桶子去；

3）对每个不是空的桶子进行排序。

4）从不是空的桶子里把项目再放回原来的序列中。

时间复杂度：O(n+C) ，C为桶内排序时间。

## 6.5 海量数据如何去取最大的k个

1. 直接全部排序（只适用于内存够的情况）

当数据量较小的情况下，内存中可以容纳所有数据。则最简单也是最容易想到的方法是将数据全部排序，然后取排序后的数据中的前K个。

这种方法对数据量比较敏感，当数据量较大的情况下，内存不能完全容纳全部数据，这种方法便不适应了。即使内存能够满足要求，该方法将全部数据都排序了，而题目只要求找出top K个数据，所以该方法并不十分高效，不建议使用。

2. 快速排序的变形 （只使用于内存够的情况）

这是一个基于快速排序的变形，因为第一种方法中说到将所有元素都排序并不十分高效，只需要找出前K个最大的就行。

这种方法类似于快速排序，首先选择一个划分元，将比这个划分元大的元素放到它的前面，比划分元小的元素放到它的后面，此时完成了一趟排序。如果此时这个划分元的序号index刚好等于K，那么这个划分元以及它左边的数，刚好就是前K个最大的元素；如果index  > K，那么前K大的数据在index的左边，那么就继续递归的从index-1个数中进行一趟排序；如果index < K，那么再从划分元的右边继续进行排序，直到找到序号index刚好等于K为止。再将前K个数进行排序后，返回Top K个元素。这种方法就避免了对除了Top K个元素以外的数据进行排序所带来的不必要的开销。

3. 最小堆法

这是一种局部淘汰法。先读取前K个数，建立一个最小堆。然后将剩余的所有数字依次与最小堆的堆顶进行比较，如果小于或等于堆顶数据，则继续比较下一个；否则，删除堆顶元素，并将新数据插入堆中，重新调整最小堆。当遍历完全部数据后，最小堆中的数据即为最大的K个数。

4. 分治法

将全部数据分成N份，前提是每份的数据都可以读到内存中进行处理，找到每份数据中最大的K个数。此时剩下N*K个数据，如果内存不能容纳N*K个数据，则再继续分治处理，分成M份，找出每份数据中最大的K个数，如果M*K个数仍然不能读到内存中，则继续分治处理。直到剩余的数可以读入内存中，那么可以对这些数使用快速排序的变形或者归并排序进行处理。

5. Hash法

如果这些数据中有很多重复的数据，可以先通过hash法，把重复的数去掉。这样如果重复率很高的话，会减少很大的内存用量，从而缩小运算空间。处理后的数据如果能够读入内存，则可以直接排序；否则可以使用分治法或者最小堆法来处理数据。

## 6.6 稳定排序哪几种？

基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序

## 6.7 快排算法，稳定性排序，快排是稳定性的吗，快排算法最差情况推导公式

1. **快排算法**

根据哨兵元素，用两个指针指向待排序数组的首尾，首指针从前往后移动找到比哨兵元素大的，尾指针从后往前移动找到比哨兵元素小的，交换两个元素，直到两个指针相遇，这是一趟排序，经常这趟排序后，比哨兵元素大的在右边，小的在左边。经过多趟排序后，整个数组有序。

稳定性：不稳定

平均时间复杂度：O(nlogn)

2. **稳定排序**

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。

快排算法是不稳定的排序算法。例如待排序数组:int a[] = {1, 2, 2, 3, 4, 5, 6};

若选择a[2]（即数组中的第二个2）为枢轴，而把大于等于比较子的数均放置在大数数组中，则a[1]（即数组中的第一个2）会到pivot的右边， 那么数组中的两个2非原序。

若选择a[1]为比较子，而把小于等于比较子的数均放置在小数数组中，则数组中的两个2顺序也非原序

3. **快排最差情况推倒**

在快速排序的早期版本中呢，最左面或者是最右面的那个元素被选为枢轴，那最坏的情况就会在下面的情况下发生啦：

1）数组已经是正序排过序的(每次最右边的那个元素被选为枢轴)

2）数组已经是倒序排过序的(每次最左边的那个元素被选为枢轴)

3）所有的元素都相同（1、2的特殊情况）

因为这些案例在用例中十分常见，所以这个问题可以通过要么选择一个随机的枢轴，或者选择一个分区中间的下标作为枢轴，或者（特别是对于相比更长的分区）选择分区的第一个、中间、最后一个元素的中值作为枢轴。有了这些修改，那快排的最差的情况就不那么容易出现了，但是如果输入的数组最大（或者最小元素）被选为枢轴，那最坏的情况就又来

快速排序，在最坏情况退化为冒泡排序，需要比较O(n2)次（n(n - 1)/2次）

# 7 哈希

# C++面试宝典

## 7.1 hash表的实现包括STL中的哈希桶长度常数

- hash表的实现主要包括**构造哈希和处理哈希冲突**两个方面

- 对于**构造哈希**来说包括**直接地址法、平方取中法、除留余数法**等

- 对于**处理哈希冲突**来说，最常用的处理冲突的方法有**开放定址法、再哈希法、链地址法、建立公共溢出区**等方法。SGL版本使用链地址法，使用一个链表保持相同散列值的元素

- 虽然链地址法并不要求哈希桶长度必须为质数，但SGI STL仍然以质数来设计哈希桶长度，并且将28个质数(逐渐呈现大约两倍的关系)计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数


## 7.2 hash表如何rehash，以及怎么处理其中保存的资源

- C++的hash表中有一个**负载因子loadFactor**，当loadFactor<=1时，hash表查找的期望复杂度为O(1)。因此每次往hash表中添加元素时，我们必须保证是在loadFactor <1的情况下，才能够添加

- 因此当Hash表中loadFactor==1时，Hash就需要进行rehash。rehash过程中，会模仿C++的vector扩容方式，Hash表中每次发现loadFactor ==1时，就开辟一个原来桶数组的两倍空间，称为新桶数组，然后把原来的桶数组中元素全部重新哈希到新的桶数组中


## 7.3 哈希表的桶个数为什么是质数，合数有何不妥？

- 哈希表的桶个数使用质数，可以最大程度减少冲突概率，使哈希后的数据分布的更加均匀。如果使用合数，可能会造成很多数据分布会集中在某些点上，从而影响哈希表效率

- 算法：给定一个数字数组，返回哈夫曼树的头指针


```cpp
struct BTreeNode* CreateHuffman(ElemType a[], int n)
{
int i, j;
struct BTreeNode **b, *q;
b = malloc(n*sizeof(struct BTreeNode));
for (i = 0; i < n; i++)
{
b[i] = malloc(sizeof(struct BTreeNode));
b[i]->data = a[i];
b[i]->left = b[i]->right = NULL;
}
for (i = 1; i < n; i++)
{
int k1 = -1, k2;
for (j = 0; j < n; j++)
{
if (b[j] != NULL && k1 == -1)
{
k1 = j;
continue;
}
if (b[j] != NULL)
{
k2 = j;
break;
}
}
for (j = k2; j < n; j++)
{
if (b[j] != NULL)
{
if (b[j]->data < b[k1]->data)
{
k2 = k1;
k1 = j;
}
else if (b[j]->data < b[k2]->data)
k2 = j;
}
}
q = malloc(sizeof(struct BTreeNode));
q->data = b[k1]->data + b[k2]->data;
q->left = b[k1];
q->right = b[k2];
b[k1] = q;
b[k2] = NULL;
}
free(b);
return q;
}
```

## 7.4 解决hash冲突的方法

当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样的现象称为哈希冲突。目前常用的解决哈希冲突的方法如下：

1. **开放定址法**: 当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止
2. **再哈希法**：当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数
3. **链地址法**：将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中
4. **建立公共溢出区**：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理

## 7.5 哈希冲突解决方法

1、开放定址

开放地址法有个非常关键的特征，就是所有输入的元素全部存放在哈希表里，也就是说，位桶的实现是不需要任何的链表来实现的，换句话说，也就是这个哈希表的装载因子不会超过1。它的实现是在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（探查序列），去寻找下一个地址，若发生冲突再去寻找，直至找到一个为空的地址为止。所以这种方法又称为再散列法。

有几种常用的探查序列的方法：

①线性探查

dii=1，2，3，…，m-1；这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。

②二次探查

di=12，-12，22，-22，…，k2，-k2   ( k<=m/2 )；这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。

③ 伪随机探测

di=伪随机数序列；具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），生成一个位随机序列，并给定一个随机数做起点，每次去加上这个伪随机数++就可以了。

2、链地址

每个位桶实现的时候，采用链表或者树的数据结构来去存取发生哈希冲突的输入域的关键字，也就是被哈希函数映射到同一个位桶上的关键字。

![img](https://uploadfiles.nowcoder.com/images/20190315/308571_1552656618645_A1331D1E34D3B9C3C4C03BC55F106A79)

紫色部分即代表哈希表，也称为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中，即链接在桶后。

3、公共溢出区

建立一个公共溢出区域，把hash冲突的元素都放在该溢出区里。查找时，如果发现hash表中对应桶里存在其他元素，还需要在公共溢出区里再次进行查找。

4、再hash

再散列法其实很简单，就是再使用哈希函数去散列一个输入的时候，输出是同一个位置就再次散列，直至不发生冲突位置。

缺点：每次冲突都要重新散列，计算时间增加。

# 随想录哈希理论基础

## 7.6 哈希表

什么是哈希表，哈希表(英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了)

> 哈希表是根据关键码的值而直接进行访问的数据结构

- 这么官方的解释可能有点懵，直白来讲其实**数组就是一张哈希表**
- **哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素**，如下图所示：

![哈希表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104234805168.png)

- 那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里**
- 例如要查询一个名字是否在这所学校里。要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到
- 我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里
- 将**学生姓名映射到哈希表**上就涉及到**hash function就是哈希函数**

## 7.7 哈希函数

- 哈希函数把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里
- 哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字

![哈希表2](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png)

- 如果hashCode得到的数值大于哈希表的大小，也就是大于哈希表的最大边界tableSize -1，怎么办呢？
- 此时为保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个取模的操作，这样就保证学生姓名一定可以映射到哈希表上
- 此时问题又来，哈希表刚刚说过，就是一个数组。
- 如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。
- 接下来**哈希碰撞**登场

## 7.8 哈希碰撞

- 如图所示，小李和小王都映射到索引下标 1 的位置，**这一现象叫做哈希碰撞**

![哈希表3](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png)

一般哈希碰撞有两种解决方法， **拉链法**和**线性探测法**

### 7.8.1 拉链法

- 刚刚小李和小王在索引1的位置发生冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王

![哈希表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png)

- **数据规模是dataSize， 哈希表的大小为tableSize**
- **拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间**

### 7.8.2 线性探测法

- 使用**线性探测法，一定要保证tableSize大于dataSize**。 需要依靠哈希表中的空位来解决碰撞问题
- 例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放冲突的数据。如图所示：

![哈希表5](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png)

## 7.9 常见三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set(集合)
- map(映射)

我们来看一下set，在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

|        集合        | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| :----------------: | :------: | :------: | :--------------: | :----------: | :------: | :------: |
|      std::set      |  红黑树  |   有序   |        否        |      否      | O(log n) | O(log n) |
|   std::multiset    |  红黑树  |   有序   |        是        |      否      | O(logn)  | O(logn)  |
| std::unordered_set |  哈希表  |   无序   |        否        |      否      |   O(1)   |   O(1)   |

- std::unordered_set底层实现为哈希表，**std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加**

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

- **std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树**。同理，s**td::map 和std::multimap 的key也是有序的**(这个问题也经常作为面试题，考察对语言容器底层的理解)
- **当要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的。如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset**
- 再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为**key的存储方式使用红黑树实现**
- 其他语言例如java里的HashMap,TreeMap都是一样的原理。可以灵活贯通
- **虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理**
- 这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？
- 实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子

![哈希表6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235134572.png)

- 总结一下，**当我们遇到要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**
- 但是哈希法也是**牺牲空间换取时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找
- 如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

# 8 动态规划

# C++面试宝典

## 8.1 手写代码最长公共连续子序列

```
int substr(string & str1, string &str2)
{
int len1 = str1.length();
int len2 = str2.length();
vector<vector<int>>dp(len1,vector<int>(len2,0));
for (int i = 0; i < len1; i++)
{
dp[i][0] = str1[i]==str1[0]?1:0;
}
for (int j = 0; j <= len2; j++)
{
dp[0][j] = str1[0]==str2[j]?1:0;
}
for (int i = 1; i < len1; i++)
{
for (int j = 1; j < len2; j++)
{
if (str1[i] == str2[j])
{
dp[i][j] = dp[i - 1][j - 1]+1;
}
}
}
int longest = 0;
int longest_index = 0;
for (int i = 0; i < len1; i++)
{
for (int j = 0; j < len2; j++)
{
if (longest < dp[i][j])
{
longest = dp[i][j];
longest_index = i;
}
}
}
```

//字符串为从第i个开始往前数longest个

```cpp
for (int i = longest_index-longest+1; i <=longest_index; i++)
{
cout << str1[i] << endl;
}
return longest;
}
```

## 8.2 手写代码求一个字符串最长回文子串

```cpp
int LongestPalindromicSubstring(string & a)
{
int len = a.length();
vector<vector<int>>dp(len, vector<int>(len, 0));
for (int i = 0; i < len; i++)
{
dp[i][i] = 1;
}
int max_len = 1;
int start_index = 0;
for (int i= len - 2; i >= 0; i--)
{
for (int j = i + 1; j < len; j++)
{
if (a[i] == a[j])
{
if (j - i == 1)
{
dp[i][j] = 2;
}
else
{
if (j - i > 1)
{
dp[i][j] = dp[i + 1][j - 1] + 2;
}
}
if (max_len < dp[i][j])
{
max_len =  dp[i][j];
start_index = i;
}
}
else
{
dp[i][j] = 0;
}
}
}
cout << "max len is " << max_len << endl;
cout << "star index is" << start_index << endl;
return max_len;
}
```

## 8.3 手写代码查找最长回文子串

```cpp
int LongestPalindromicSubstring(string & a)
{
int len = a.length();
vector<vector<int>>dp(len, vector<int>(len, 0));
for (int i = 0; i < len; i++)
{
dp[i][i] = 1;
}
int max_len = 1;
int start_index = 0;
for (int i= len - 2; i >= 0; i--)
{
for (int j = i + 1; j < len; j++)
{
if (a[i] == a[j])
{
if (j - i == 1)
{
dp[i][j] = 2;
}
else
{
if (j - i > 1)
{
dp[i][j] = dp[i + 1][j - 1] + 2;
}
}
if (max_len < dp[i][j])
{
max_len =  dp[i][j];
start_index = i;
}
}
else
{
dp[i][j] = 0;
}
}
}
cout << "max len is " << max_len << endl;
cout << "star index is" << start_index << endl;
return max_len;
}
```
